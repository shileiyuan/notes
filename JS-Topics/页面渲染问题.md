### 重绘
重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。

### 重排
重排是更明显的一种改变，可以理解为渲染树需要重新计算。

#### 常见的触发重排的操作：
1. DOM元素的几何属性变化
  当DOM元素的几何属性变化时，渲染树中的相关节点就会失效，浏览器会根据DOM元素的变化重新构建渲染树中失效的节点。之后，会根据新的渲染树重新绘制这部分页面。而且，当前元素的重排也许会带来相关元素的重排。例如，容器节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点的重排，祖先节点需要重新计算子节点的尺寸也会产生重排。最后，每个元素都将发生重绘。可见，重排一定会引起浏览器的重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。
2. DOM树的结构变化
  当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。浏览器引擎布局的过程，类似于树的前序遍历，是一个从上到下从左到右的过程。通常在这个过程中，当前元素不会再影响其前面已经遍历过的元素。所以，如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元素，则不会影响到前面的元素。
3. 获取某些属性
  浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。
  此外，改变元素的一些样式，调整浏览器窗口大小等等也都将触发重排。

#### 在开发中，应该尽量减少重拍次数或缩小重排的影响范围：
1. 将多次改变样式属性的操作合并成一次操作：
    ```javascript
    var changeDiv = document.getElementById('#changeDiv');
    changeDiv.style.color = '#093';
    changeDiv.style.background = '#eee';
    changDiv.style.height = '200px';
    
    可以合并成：
    div.changeDiv{
      background: #eee;
      color: #093;
      height: 200px;
    }
    
    document.getElementById('changeDIV').className = 'changeDiv';
    ```

2. 将需要多次重排的元素，position属性设置为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素最好都设置为绝对定位。
3. 在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取数据表格，渲染到页面。可以先取得数据后在内存中构建整个表格等等html片段，再一次性添加到文档中去，而不是循环添加每一行。
4. 由于display属性为none的元素不再渲染树中，对隐藏的元素操作不会引发其它元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。
5. 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。